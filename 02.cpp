/**
  题目：对数组 [45,38,65,97,76,13,27,49] 进行快速排序，第二次划分的数组是？
  
  答案：[27,38,13,45,76,65,97,49] 
*/

/**

快速排序 partition 思路：
  如果没有特殊说明，都是以序列中的第一个元素作为“关键值”。
  整个partition函数的核心作用就是找到这个“关键值”的位置
  
  如果后一个元素比key值大，那么不需要处理，i++即可
  如果前一个元素比key值小，那么交换 arr[i] 和 arr[++j]
  
  过程如下：
  
  第一次partition：key值是45
  
  [45,38,65,97,76,13,27,49] ==>
  
  38 < 45, 那么交换 arr[i] 和 arr[++j], i = l+1, ++j = l+1, 所以 交换 38 和 38，因此无需要交换值, ++i
  :[45,38,65,97,76,13,27,49] ==>  
  
  65 > 45, 那么 i++即可
  :[45,38,65,97,76,13,27,49]
  
  97 > 45, 那么 i++即可
  :[45,38,65,97,76,13,27,49]
  
  76 > 45, 那么 i++即可
  :[45,38,65,97,76,13,27,49]
  
  13 < 45, 那么 13 <==> 65, ++j
  :[45,38,13,97,76,65,27,49]
  
  27 < 45, 那么 27 <==> 97, ++j
  :[45,38,13,27,76,65,97,49]
  
  这时循环结束，将 27 <==> 45
  
  第一次paptition结束：
  [27,38,13,45,76,65,97,49]
  
  第二次partition：
  
  [27,38,13,45,76,65,97,49] ==> key值为27
  
*/

#include <algorithm>

template <typename T>
int partition(T arr[], int l, int r)
{
  T key = arr[l];
  
  int j = l;
  for (int i = l+1; i <= r; ++i) {
    if (arr[i] < key) {
      std::swap(arr[j+1], i);
      ++j;
    }
  }
  
  std::swap(arr[j], arr[l]);
  return j;
}
